#!/usr/bin/python3 
# addr.py
# This is a simple application to keep track of contact information from the terminal

''' TODO
  develop add_contact
  develop delete_contact
  develop search_book
  develop update_contact
  develop help function to explain cli syntax
  debug *
  rework open_book
'''
import argparse
import os
import pprint
import re
import sys

DEFAULT_PATH = os.path.join(os.path.expanduser('~'),  '.addr_book')
DEFAULT_BACUP_PATH = os.path.join(os.path.expanduser('~'), '.addr_book_backup')

def build_contact(line): 
# recieves a line uses regex to build key value pairs and return a dictionary with those values
  copy = line
  values_regex = re.compile(r'''(
                                (?<=name:)[a-zA-Z\s]*          #contact name
                                |(?<=homep:)[0-9\.\-\(\)x]*    #contact home phone
                                |(?<=cellp:)[0-9\.\-\(\)x]*    #contact cell phone
                                |(?<=workp:)[0-9\.\-\(\)x]*    #contact work phone
                                |(?<=emailp:)[a-zA-Z0-9\@\._]* #contact personal email
                                |(?<=emailw:)[a-zA-Z0-9\@\.]*  #contact work email
                                )''', flags=re.X)
  keys_regex = re.compile(r'(name|cellp|workp|homep|emailp|emailw)')

  values = re.findall(values_regex, copy)
  return dict(zip(keys, values))

def handle_args(ARGS):

  

def open_book():
  if not os.path.isfile(path):
    open(DEFAULT_PATH, 'w').close() # creates an addr_book file if one does not exist

  try:
    contacts = []
    with open(default_path) as f:
      contacts = [build_contact(line) for line in f]
  except OSError as err1:
     print('Could not open \'addr_book\' at the default path')
     sys.exit()
  finally:
     return contacts

def print_book():
  [pprint.pprint(j) for i,j in enumerate(contacts)]
   
#def search_book(contacts_list): 
  #.isalpha(query.strip()) = Name search
  #  .isdecimal(query.strip(-()) = Phone search
  #  .isalnum(query.lower().strip()) = Email search

#def update_contact():

def main():
  parser = argparse.ArgumentParser(description='Terminal application to keep track of a contact information')
#parser.add_argument('--add', '-a', type=str, default=None, 
#                      help='''Add a new contact to the addr_book file formated as a python dictionary
#                               Must provide at least the name key''')
#parser.add_argument('--delete', '-d', type=str, default=None, 
#                       help='Delete a contact from the addr_book file')
#parser.add_argument('--print', '-p', type=str, default='*',
#                       help='Prints contact information for one or all of the contacts')
#parser.add_argument('--update', '-u', type=str, default=None,
#                       help='Updates an existing contact')
  parser.add_argument('--operation', '-o',
                       type=str, default='--help',
                       choices=['add', 'delete', 'print', 'update'],
                       help='The operation you would like to perform')
  args = parser.parse_args()
  print(type(args))

  handle_args(args)


# Statement to call the main function
if __name__ == '__main__':
  main()
